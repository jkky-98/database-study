# 복합 인덱스
둘 이상의 컬럼을 조합한 인덱스로 실제 운영환경에서는 단일 인덱스보다 훨씬 많이 사용된다.

실제로 where절의 조건에 조건을 하나만 배치하는 경우보다 다수 배치하는 경우가 더 많기 때문이다.

다중 조건 쿼리의 성능을 최적화 하기위해 사용하는 것이 바로 복합인덱스이다.

## 컬럼의 순서

복합인덱스에서 가장 중요한 것은 컬럼의 순서이다.

```sql
create index idx_items_category_price on items(category, price);
create index idx_items_price_category on items(price, category);
```
위 쿼리는 복합 인덱스로 사용할 컬럼들의 순서의 경우의 수이다.

먼저 오는 컬럼의 정렬을 기준으로 두번째 오는 컬럼이 2차 정렬된다.

2차 정렬된 컬럼은 1차 정렬된 컬럼에 매우 종속적으로 바뀐다.

2차 정렬된 컬럼은 그 자체로만으로는 정렬상태라고 볼 수 없기 때문이다.

1차 정렬된 컬럼의 값이 동일한 경우 안에서만 2차 컬럼이 정렬되었다고 볼 수 있다.

이러한 차이점은 복합인덱스 사용법에 있어 주의를 요한다.

```sql
create index idx_items_category_price on items(category, price);
--- category로 1차 정렬
--- price로 2차 정렬
```
- 이 인덱스는 복합인덱스이지만 `where category = 'A'`와 같은 단일 컬럼에 대해서도 옵티마이저가 이 복합인덱스를 선택할 수 있다.

- 하지만 `where price = 3000`과 같은 2차 인자로 준 컬럼을 단일 조건으로 사용하면 위 복합인덱스 사용은 불가능하다. 당연히, price 그 자체만으로는 정렬되어있지 않기 때문이다.

- `where category = 'A' and price = 3000` or `where price = 3000 and category = 'A'`와 같이 두 개를 모두 사용하였을 경우 category의 인덱스를 먼저 타서 category가 특정되면 그것에 해당하는 price를 추적하면 모두 정렬상태기에 2차 정렬된 price도 사용 가능하다.

(category, price)     →     id (PK)
------------------           --------
('A', 1000)                 →   1
('A', 2000)                 →   2
('A', 3000)                 →   3   
('A', 4000)                 →   4
('B', 1000)                 →   5
('B', 3000)                 →   6
('C', 3000)                 →   7

위 예시에서 'A'에 대해서만 관찰할 경우 price는 정렬상태이다.

인덱스 왼쪽 접두어 규칙 : 이처럼 복합 인덱스는 첫 번째 컬럼 기준으로 정렬된 상태에서만 제 역할이 가능하다.

인덱스를 (A컬럼, B컬럼, C컬럼)순으로 생성했다면

WHERE조건으로 (A, B, C), (A, B), (A) 만 가능하며, (A,C), (B,C), (B), (C)와 같은 경우는 불가능하다.

(A,C)도 불가능한 이유는 3개를 연결했을 때 첫번째 요소를 뽑은들 C컬럼(3차 정렬)에서 정렬이 절대 보장되지 않기 때문이다.

# 범위조건에 대한 주의사항

(category, price)     →     id (PK)
------------------           --------
('A', 1000)                 →   1
('A', 2000)                 →   2
('A', 3000)                 →   3   
('A', 4000)                 →   4
('B', 1000)                 →   5
('B', 3000)                 →   6
('C', 1500)                 →   7

일 경우 인덱스의 순서를 지키더라도 복합인덱스 활용이 불가능하다.

`where category > 'A' and price = 3000`

A보다 크다는 것은 알파벳 순 상 B,C를 나타낼 것이고

B,C 를 합쳐서 볼 경우 price는 정렬상태가 아니게 된다.

그렇기에 price의 정렬을 사용하지 못하게 되며 이는 흔히 발생하는 복합 인덱스가 잘못사용된 경우이다.

그렇기에 복합인덱스 설계시 복합인덱스에서 쓰이는 컬럼이 범위조건으로 많이 쓰인다면

복합인덱스의 가장 후순위에 배치해야 한다.

범위 선택을 하여 여러개가 선택될 경우 그 다음 정렬을 절대 이용할 수 없기 때문이다.

## 팁 : IN절 트릭

실무에서 카테고리 값과 같이 연속된 수의 값이 아닌 컬럼이면서 카테고리의 종류가 많지 않을 경우,
(배송중, 구매완료, 상품준비중)과 같이.

`where status IN (구매완료, 상품준비중) and price = 3000`

이렇게 사용할 경우 구매완료, 상품준비중 각각에 대해서 price 2차 정렬을 이용할 수 있게 되므로

복합인덱스를 활용하는 데 훨씬 유리할 수 있다.

# 복합 인덱스 대원칙 
1. 인덱스는 순서대로 사용 -> (1), (1,2), (1,2,3), (1,2,3,4)
2. 등호 조건은 앞으로 범위조건은 뒤로 
3. 정렬도 인덱스 순서대로 사용 -> 정렬또한 이 법칙을 지키면 filesort없이 인덱스의 정렬상태를 그대로 활용할 수 있다.

