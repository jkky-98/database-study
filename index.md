# 인덱스(Index)

주로 인덱스를 설정한다, 적용한다라는 표현으로 인덱스 적용을 설명한다.

인덱스를 설정하면 테이블처럼 하나의 데이터 구조가 생성된다.(당연히 저장비용이 추가된다.)

만약 A컬럼에 인덱스를 지정한다면 A컬럼에 대한 인덱스 데이터 구조가 하나 생성되는 것이다.

인덱스는 풀 스캔의 공포를 해결해준다.

데이터가 수십만 건인 테이블에서 무언가 하나를 찾기 위해서 가장 원초적인 방식은 하나하나 찾아가는 것이다.

운이 좋다면 처음 서칭할 때 해당 레코드를 발견하는 것이고 운이 좋지 않다면 마지막 경우에서 발견할 것이다.

최악을 가정할 때 수천만 건의 테이블에서 단지 하나의 데이터를 찾기 위해 엄청난 수고를 들이는 것이다.

인덱스를 활용하면 이에 대한 비효율을 깰 수 있다.

**서비스의 핵심 기능에서 가급적 풀테이블 스캔이 발생하지 않도록 설계하는 것은 기본 덕무이다.**

빼곡한 영어사전에서 단어를 찾을 때 첫페이지 부터 마지막 페이지까지 찾으려는 단어를 찾는 사람은 없을 것이다.

주로 첫글자로 하여금 알파벳순으로 범위를 좁혀가며 찾아간다. 인덱스의 활용가치도 동일하다.

## 예시

만약 items라는 테이블이 존재하고 해당 테이블에는 수천만건의 레코드가 존재한다고 가정해보자.

```sql
select 
    *
from
    items
where item_name = '게이밍 노트북'
```
이 쿼리이전에 item_name 컬럼에 인덱스를 설정했다면,

| item\_name   | id   |
| ------------ | ---- |
| Gaming Chair | 1002 |
| Gaming Mouse | 1045 |
| 게이밍 노트북      | 1100 |
| 게이밍 노트북      | 1143 |
| 게이밍 의자       | 1180 |
| 노트북          | 1300 |
| 스마트폰         | 1450 |
| ...             | ... |
쿼리 옵티마이저는 위 인덱스(item_name 인덱스)를 탈 것이다.

인덱스는 기본적으로 정렬된 구조를 가진다.

위 예시는 텍스트 글자 순으로 정렬된 모습을 볼 수 있다.

정렬되어있다면 트리 알고리즘을 활용해서 빠르게 게이밍 노트북 부분을 찾아낼 수 있다.

그리고 id를 알아내어 본 테이블에서 한번에 조회할 수 있다.

## 인덱스가 가진 트리구조

인덱스는 기본적으로 트리구조를 활용한다.

항상 정렬된 상태를 유지하며 새로운 데이터가 들어올 때에도 정렬된 상태를 유지하도록 수정된다.

풀 스캔의 경우 O(N)의 성능을 가진다.

트리구조의 스캔의 경우 O(logN)의 성능을 가진다.

쉽게 이진트리로 비유하자면

데이터를 반씩 죽여나가며 찾을 수 있다는 것이다.

0 ~ 100 까지 정렬되어있고 40을 찾는다면 우선 50보다 큰지 작은지 비교해서 

작으니까 50 이상의 데이터를 모두 배제하고 0~50으로만 범위를 축소할 수 있다.

전체 갯수에 대해 두 배씩 늘어나거나, 두 배씩 줄어드는 것은 엄청난 수의 변화이기 때문에

O(N)과 O(logN)의 속도 차이는 데이터가 클 수록 더 체감이 된다.

종이를 42번 접으면 달까지 쌓아올릴 수 있다.

실제로 최근의 데이터베이스들은 단순한 이진 트리를 이용하지 않고 B-Tree, B+Tree 등을 활용하지만 근본적인 개념은 비슷하다.(기하급수적으로 쳐내면서 서칭해나가는 것)

### 데이터 추가 관점

A테이블의 A컬럼에 인덱스를 설정했다면

A테이블에 데이터를 추가할 때 인덱스에해도 해당 컬럼에 대한 추가가 일어난다.

만약 비어있는 A테이블에 A컬럼의 값이 1,5,7,10,20를 순서대로 추가할 경우

Step 1: Insert 1
    1

Step 2: Insert 5
    1
     \
      5

Step 3: Insert 7
    1
     \
      5
       \
        7

Step 4: Insert 10
    1
     \
      5
       \
        7
         \
          10

Step 5: Insert 20
    1
     \
      5
       \
        7
         \
          10
            \
             20

이렇게 트리가 형성된다면 7을 검색하기 위해서는 두번의 서칭, 20을 검색하기 위해서는 5번의 서칭이 일어나며 이는 O(N)에 해당되어 사실상의 풀 테이블 스캔에 해당한다.

그렇기에 데이터베이스는 트리가 비효율적으로 구조화되어있을 경우 이를 재배치하여 트리기법의 효율을 온전히 이용할 수 있도록 한다.

Balance Tree
      7
     / \
    5   10
   /      \
  1        20

# 인덱스 추가, 삭제, 조회
```sql
CREATE INDEX 인덱스이름 ON 테이블이름 (컬럼1, 컬럼2, ...); ---추가
DROP INDEX 인덱스이름 ON 테이블이름; ---삭제
SHOW INDEX FROM 테이블이름; ---조회
```

# 인덱스 활용 확인 : EXPLAIN

위에서 인덱스를 생성하는 법을 파악했고, 실제로 인덱스를 적용할 경우

```sql
select
    *
from
    items
where 인덱스_걸린_컬럼 = 3;
```
은 대용량의 테이블이란 가정에서 기존보다 더 빨리 수행완료 될 것이다.

정말로 인덱스를 활용해서 더 빨리 수행되는지 알아보기 위해 셀렉트문 앞에 `EXPLAIN`을 적용하면 

쿼리 옵티마이저에 의한 실행계획을 볼 수 있다.

## 결과 해석
- stock_quantity에 인덱스 걸리지않음.
- cateogry에 인덱스 걸림.
```sql
--- stock_quantity 조건 조회 예시
explain select * from items
where stock_quantity = 90
```
```json
// 결과
[
  {
    "id": "1",
    "select_type": "SIMPLE",
    "table": "items",
    "partitions": null,
    "type": "ALL",
    "possible_keys": null,
    "key": null,
    "key_len": null,
    "ref": null,
    "rows": "25",
    "filtered": 10,
    "Extra": "Using where"
  }
]
```
위 json결과는 실행 계획 쿼리에 대한 보고서를 json으로 출력한 것이다.
주요 팩터만 설명하자면
1. type(가장 중요) : ALL -> 풀 테이블 스캔했다는 것 (인덱스를 사용했다면 ref, range)등이 나타남.
2. key : NULL -> 어떠한 인덱스도 사용안됨
3. rows : 25 -> 25개의 행을 탐색할 예정이라는 것 (테이블의 전체 레코드가 25개이므로 풀스캔)
4. filtered : 10.00 -> 테이블에서 읽어온 행들 중 where 조건 필터링 이후 남을 행의 비율 예측치
5. Extra : Using where -> where절의 조건으로 필터링 했다는 것

```sql
--- cateogory 조건 조회 예시
explain select * from items
where category = '헬스/뷰티'
```
```json
// 결과
[
  {
    "id": "1",
    "select_type": "SIMPLE",
    "table": "items",
    "partitions": null,
    "type": "ref",
    "possible_keys": "idx_items_category_isactive_stock_quantity",
    "key": "idx_items_category_isactive_stock_quantity",
    "key_len": "402",
    "ref": "const",
    "rows": "2",
    "filtered": 100,
    "Extra": null
  }
]
```
1. type(가장 중요) : ref -> 참조를 사용, 인덱스를 사용했다는 뜻
2. key : "idx_items_category_isactive_stock_quantity" 라는 인덱스를 사용함
3. rows : 2 -> 2개의 행을 탐색할 것으로 예측된다는 말
4. filtered : 100 -> 필터링 안할 것이라는 말 (where에 의한 필터링이 필요없어짐)
5. Extra : null (where에 의한 필터링 안함, 이미 인덱스에서 다 걸러낼 수 있었으니까)

# 더 알아가야할 것
- 동등 비교 조건에서의 인덱스 활용시 type = ref
- Between, >, <와 같은 범위 조건에서 type = range
- LIKE 검색시 `검색어%`만 인덱스를 탈 수 있음. `%검색어%`, `%검색어`는 불가능 어순 정렬을 활용할 수 없기 때문
- 인덱스를 정렬조건에 쓴다면 정렬과정(filesort)을 생략할 수 있음. 인덱스는 이미 정렬되어있기 때문
- 내림차순 정렬에 대해서는 역방향 스캔을 통해 filesort를 피함, 정방향보다 아주 약간 느리나 고려안해도될 수준

# 옵티마이저의 인덱스 선택 기준
쿼리 옵티마이저 쿼리 실행이전 여러 실행가능한 방법을 평가하여 가장 비용이 적은 방법을 선택한다.

인덱스가 걸려있음에도 풀 테이블 스캔이 효율적인 경우 쿼리 옵티마이저는 풀테이블 스캔을 선택할 수 있다.

인덱스가 이득인가, 풀테이블 스캔이 이득인가를 두고 쿼리옵티마이저는 인덱스 손익분기점이라는 자신만의 기준을 두고 선택한다.

인덱스를 활용하는 절차를 살펴보자.

1. 인덱스 탐색
2. 인덱스에서 얻은 ID로 테이블 접근

풀 테이블 스캔의 절차는 간단하다.

1. 테이블 탐색

인덱스를 활용하는 절차에서 우리는 이전 `1.인덱스 탐색`에 대한 효율성을 파악했다. 트리 검색을 통해 기하급수적으로 탈락후보들을 만들어 빠른 서칭을 이루었다.

하지만 `2. 인덱스에서 얻은 ID로 테이블 접근`에 대해선 평가하지 못했는데, 예상만으로는 굉장히 빠를 것이라고 추측된다.

ID로 하여금 바로 해당 레코드를 찾아가기에 그렇다.

하지만 테이블에 접근한다는 것 자체의 비용을 생각하면 "어떠한 경우"에서 풀테이블 스캔보다 비용소모적이다.

그 "어떠한 경우"란 `Random I/O`를 말한다.

만약 인덱스에서 얻은 ID가 하나가 아니라 여러개라면(범위 검색), 비연속적인 ID 집단이 1차적으로 걸러진다.

예로 (1, 1001, 502, 91, 6045...)와 같이 순서도 정렬도 안된 ID집합을 얻어 이를 하나하나 테이블에 대응시킨다.

만약 이 ID값이 원래 테이블의 총 레코드 수의 50%라고 가정해보자.

데이터는 총 1억건이라고 가정하면, 인덱스로부터 얻은 ID값들이 5천만개에 해당한다.

이 순서성없는 5천만개를 하나하나 연결하는 것은 차라리 풀 테이블 스캔(1억개)를 하는게 나을 정도로 비효율적으로 변한다.

그것은 하드웨어(저장장치)의 문제에 기인한다.

하드웨어는 1,2,3....과 같은 연속적인 순서에 더 잘 대응한다. 1, 1001, 502, 91, 6045...와 같은 순서는 저장장치이의 이부분 저부분을 참조하는 것이기 때문에 비효율적이다.

글만으로 잘 느껴지지않는다면 비유를 들어보겠다.

영단어가 1억개 있는 사전이라고 가정하고 뒤죽박죽 섞인 5000만개의 영단어 리스트를 받아 색인을 참고하면서 5000만개를 찾을빠에는 그냥 처음부터 끝까지 살펴보며 5000만개 영단어를 찾는 것이 더 빠르다는 것이다. 3page -> 144page -> 500page -> 5page 이렇게 많이 읽을바에 1~1000page를 그냥 다 읽는 것이 낫다는 것이다.

# 커버링 인덱스

랜덤 I/O를 유발하지 않으려면 select 선택 자체를 인덱스가 걸린 컬럼만 선택할 경우 랜덤I/O문제를 벗어날 수 있다.

테이블을 찾아가지 않고 인덱스에서만 데이터를 가져오기 때문이다.

만약 여러 컬럼을 select하고 싶다면 복합 인덱스를 사용할 수 있다.

