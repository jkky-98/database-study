# 서브 쿼리

## JOIN으로는 답할 수 없는 문제
Q : `우리 쇼핑몰에서 판매하는 상품들의 평균 가격보다 비싼 상품은 무엇이 있을까`

이 질문에서 건들여야할 테이블은 products, 즉 상품 정보 테이블 하나만 존재하기에 join은 고려대상이 아니다.

판매하는 상품들의 평균 가격을 where 조건절에서 활용할 수 있다면 위 질문에 대한 대답을 할 수 있다.

하지만 이를 하나의 쿼리로 형성할 수는 없고

1. 평균 가격을 구하는 쿼리
2. 평균 가격으로 where을 구성해서 필터링된 결과를 얻는 쿼리

두 절차를 거쳐야한다.

서브쿼리로 하여금 where 조건절에 `1.`과정을 그대로 넣을 수 있다.

```sql
select
    *
from
    products
where price > (
    select avg(price) from products
);
```
`select avg(price) from products` 이 결과는 컬럼명이 `avg(price)`인 컬럼을 하나만 가지며 하나의 행만 가진다.

# 스칼라 서브 쿼리

위의 예시처럼 하나의 컬럼, 하나의 행으로만 존재하는 경우 스칼라 서브쿼리라고 한다.

위의 쿼리문 예시의 where에서 스칼라 서브쿼리를 활용했는데 만약 스칼라 서브쿼리가 아닌, 다중 행 혹은 다중 컬럼 혹은 다중 행 + 다중 컬럼의 결과일 경우 에러가 난다.

# 다중 행 서브쿼리

당연하게도 다중 행 서브쿼리는 > = 와 같은 단일 스칼라 값을 활용하는 연산기호를 사용할 수 없다.

where price > (1000, 2000, 3000)은 받아들여질 수 없는 연산이기 때문이다.

그렇기에 IN, ANY, MAX, ALL, MIN을 보통 활용한다.

IN 연산자로 하여금 목록에 포함된 값과 일치하는지 확인하는 방식으로 연산을 짤 수도 있고

ANY와 ALL은 주로 <, >와 같은 비교 연산자와 함께 사용된다.

`price < ANY(다중 행 서브쿼리 결과)` : price가 서브쿼리 결과의 가장 큰 값보다 작을 때 true
`price < ALL(다중 행 서브쿼리 결과)` : price가 서브쿼리의 모든 결과보다 작을 때 true

**비교연산자 + ANY, ALL은 생각이 꼬일 수 있기에 보통 MIN, MAX를 활용하는 것이 편하다.**

# 다중 컬럼 서브쿼리

```sql
SELECT order_id, user_id, status, order_date
  FROM orders
  WHERE (user_id, status) = (SELECT user_id, status
                             FROM orders
                             WHERE order_id = 3);
```
다중 컬럼이면서 단일 행일 경우 위와같이 풀어낼 수 있다.

역시 동일하게 다중컬럼+다중행일 경우 IN, ANY, MAX, ALL, MIN과 같은 것을 활용해야한다.

비교군은 당연히 컬럼수와 같아야한다.

# 상관 서브쿼리

상관 서브쿼리는 서브쿼리가 메인쿼리의 값에 의존하는 경우이다.

`각 상품별로, 자신이 속한 카테고리의 평균 가격 이상의 상품들을 찾아라`와 같은 문제가 주어졌을 때 상품 테이블의 각각의 행들에 대응되는 카테고리 평균값이 존재할 것이다.

만약 이를 서브쿼리 없이 풀어낸다면 직접 모든 평균값을 조사하여 카테고리마다 쿼리를 짜주어야 할 것이다.

상관 서브쿼리를 활용하면 이를 쉽게 풀어낼 수 있다.

```sql
SELECT
      product_id,
      name,
      category,
      price
FROM
products p1
WHERE
      price >= (
                SELECT
                    AVG(price)
                FROM
                    products p2
                WHERE
                    p2.category = p1.category
        );
```

상관 서브쿼리는 쿼리 실행 순서가 독특한데,

product 테이블 첫 행을 읽어 category를 파악하여 서브쿼리(p1.category) 부분에 전달하고

서브쿼리가 실행된다.

또 다시 product 테이블 두번째 행을 읽고 category를 파악하여 서브쿼리에 전달하고 서브쿼리가 실행된다.

이를 반복한다.

즉 product테이블의 행의 수만큼 서브쿼리가 실행된다.(비용에 관한 문제인식이 생기게 된다.)

## 서브 쿼리에서 유의해야할 점

```sql
SELECT
      product_id,
      name,
      price
FROM
    products
WHERE
    product_id IN (SELECT DISTINCT product_id FROM orders);
```
이 쿼리의 목적은 orders 테이블에서 unique한 product_id들을 구하여 products 테이블의 조건절로 쓰는 것이다.

이 쿼리의 실행 흐름을 보면

orders 테이블을 전체 서칭한 후 결과를 메인 쿼리에서 사용한다.

**만약 orders 테이블의 행이 수억개라면? -> 충분히 가능성 있는 이야기다. 주문은 한 회원이 여러번 수행할 수 있기 때문에 전체 회원에 대해 주문 데이터가 얼마나 존재할 지 예상해보면 엄청난 레코드 수가 예상될 수 있다.**

우리가 필요한 것은 쇼핑몰에 등록된 상품이 하나라도 주문되어있다면 그것을 캐치하는 것이다.

하지만 `select distinct product_id from orders`부분은 등록된 상품의 전체 주문 수를 모두 파악해버린다.

즉 필요 이상의 서칭이 진행된다는 뜻이다.

### EXISTS로 하여금 이를 해결

EXISTS는 서브쿼리의 결과에는 관심 없고 오직 서브쿼리 결과로 행이 하나라도 존재하는지 여부만 체크한다.

하지만 위 예시쿼리문과 다른 점은 `상관 서브쿼리`를 이용한다는 점에서 서브쿼리의 횟수가 늘어난다.

```sql
SELECT
      product_id,
      name,
      price
FROM
      products p
WHERE EXISTS (
      SELECT 1
      FROM orders o
      WHERE o.product_id = p.product_id
);
```
- SELECT 1의 경우 1에 들어가는 값을 어느 것으로 해도 상관없지만 관례상 1을 쓴다. 어차피 우리가 관심있는 부분은 값이 있냐 없냐만 따지기 때문이다.

이 쿼리의 실행흐름은 다음과 같다.

1. 메인쿼리의 from 테이블의 첫번째 행에 대해 product_id를 구해 서브쿼리에 이를 적용한다.
2. where 조건에 true인 경우 한 케이스라도 발견되면 곧장 true를 내뱉어서 메인쿼리 where문의 true조건이 성립된다.
3. 만약 하나도 없을 경우 product_id가 동일한 경우에 대해서 전체 서칭이 일어난다. -> EXISTS 문이 false가 될 것이다.

### 찜찜한 부분

결국 EXISTS 방식은 상관 서브쿼리를 이용하여 여러번의 서브쿼리 수행을 가져온다.

그렇기에 메인 쿼리의 from절에 오는 테이블 자체의 크기가 그렇게 크지 않으면 더 효율적일 것으로 판단된다.

서브쿼리를 이용할 경우 위 IN 방식보단 EXISTS 방식이 나아보인다.

하지만 그것은 존재성을 확인하는 필터링에서만 유효하다.

# JOIN vs SubQuery

서브쿼리를 학습하다보면 드는 생각이, 이 문제를 풀기위해 유일한 방법은 서브쿼리인건가? 라는 것이다.

사실 대부분의 문제는 서브쿼리로도 JOIN으로도 풀린다.

그리고 **일반적으로 JOIN을 활용하는 것이 성능적으로 우수하다.**

그 이유는 데이터베이스의 두뇌 역할을 하는 `쿼리 옵티마이저`에 있기 때문이다.

쿼리 옵티마이저는 우리가 던져준 쿼리문의 전체를 분석하여 가장 효율적인 실행계획을 짠다.

join 구문은 옵티마이저에게 더 많은 정보를 제공하기 때문에 쿼리 옵티마이저의 최적화를 바랄 수 있다.

서브쿼리는 이러한 문제에 있어 한정적이지만 최근의 DB 버전들은 매우 똑똑해져서, 간단한 IN 서브쿼리정도는 내부적으로 JOIN으로 바꾸어 실행하기도 한다.

그럼에도 서브쿼리의 의의는 존재하는데,

서브쿼리를 활용하는 것이 인간의 사고 흐름과 비슷하다는 점에서 가독성의 우위가 존재한다.

## 사용 규칙을 어떻게 만들어야할까?

1. JOIN을 우선적으로 고려하자.

2. JOIN을 활용했을 때 너무(x5) 가독성이 떨어지는 경우라면 서브쿼리를 이용하자 (특히 인라인 뷰를 사용해야만 깔끔하게 풀리는 문제는 서브쿼리가 정답이다.)

3. EXISTS를 활용하자.

4. 성능이 의심될 때는 반드시 측정하라! - EXPLAIN과 같은 도구가 존재한다. 이를 통해 실행계획을 분석할 수 있다.